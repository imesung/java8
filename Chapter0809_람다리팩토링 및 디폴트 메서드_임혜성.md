## 람다를 활용한 리펙토링

### 람다로 객체지향 디자인 패턴 리팩토링 가능

* 인터페이스의 재정의 하는 클래스는 안 만들고, 람다를 이용해서 전달 가능
* 리팩토링 하는 디자인 패턴 종류
  * 전략, 탬플릿 메서드, 옵저버, 의무체인, 팩토리

### 람다의 디버깅

* 스택 트레이스 확인
  * 스택 프레임
    * 프로그램이 메서드를 호출할 때마다 프로그램에서의 호출 위치, 호출할 때의 인수값, 호출된 메서드의 지역 변수 등을 포함한 호출 정보들을 말함
  * 문제가 발생한 지점에 이르게 된 메서드 호출 리스트를 얻을 수 있음.
* 람다에서 에러
  * lambda$main$0이라는 생소한 이름의 에러 메시지가 노출

### 정보 로깅

* peek
  * 스트림 파이프라인에 적용된 각각의 연산이 어떤 결과를 노출하고 있는지 확인 가능
  * Ex.
    * stream().peek(sysout).map().peek(sysout).filter()...



## 디폴트 메서드

* 인터페이스에 메서드의 동작을 구현.

### API의 변화

~~~ 
1. 공개된 API를 고치게 되면 해당 API를 사용한 클라이언트의 프로젝트에 에러가 발생하므로 API를 고치기는 어려움
2. 디폴트 메서드 사용 시 이 문제를 해결할 수 있음
3. 디폴트 메서드를 이용해서 API를 수정하게 되면, 수정한 인터페이스에서 자동으로 기본 구현을 제공하므로 기존 코드를 고치지 않아도 됨.
~~~

### 디폴트 메서드란?

~~~ 디폴트
1. 기존 인터페이스에 디폴트 메서드 구현
2. 해당 인터페이스를 구현하는 클래스에서 디폴트 메서드를 재정의 하는 것이 아니라, 인터페이스에서 구현을 하므로 자동으로 이 메서드를 상속받는 것.
~~~

* 함수형 인터페이스는 오직 하나의 추상메서드만 포함하되, 디폴트 메서드는 해당되지 않음.
* 추상 클래스와 자바8 인터페이스 차이
  * 클래스는 하나의 클래스만 상속 받음 | 인터페이스는 여러개 구현 가능
  * 추상 클래스는 인스턴스 변수로 공통 상태를 가짐 | 인터페이스는 인스턴스 변수 가질 수 없음

### 디폴트 메서드 활용

~~~ 디폴트 메서드 활용
- 클래스에서 디폴트 메서드를 가진 여러 인터페이스를 상속 받을 시, 클래스 하나로 성격에 맞는 여러 동작을 수행할 수 있음.
- 다시 말하지만, 인터페이스의 동작을 수정할 시 디폴트 메서드를 수정하는 것이므로 클래스 쪽에 수정은 불필요.
~~~

### 같은 시그너쳐로 인한 해석 규칙

* 자바8에는 디폴트 메서드가 추가되었으므로 같은 시그너처를 갖는 디폴트 메서드를 상속받는 상황이 발생 가능.
* 다른 클래스나 인터페이스로부터 같은 시그너처를 갖는 메서드를 상속받을 시 규칙

~~~ 해석규칙
1. 클래스가 항상 이김 - 디폴트 메서드보다 클래스에 정의한 메서드가 우선순위 가짐
2. 1번 규칙의 상황이 아닌 이상 서브인터페이스가 이김 - 혹 B가 A를 상속받는 다면 B가 이김
3. 여전히 우선순위가 결정되지 않는다면, 디폴트 메서드를 오버라이드 혹은 호출해야 함. - 호출  : B.super.hello();
~~~

